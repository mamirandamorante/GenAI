# -*- coding: utf-8 -*-
"""Agent_Example.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dL8WqbcYtWAXZblUbYebyMf_UY50uEY0
"""

# =================================================================
# BUILDING A SIMPLE AI AGENT
# =================================================================
#
# What is an AI Agent?
# An AI Agent is like a smart assistant that can:
# 1. Listen to what you ask
# 2. Think about what tools it needs to help you
# 3. Use those tools to get information
# 4. Give you an answer
# 5. Remember the conversation for context
#
# Think of it like a helpful friend who has access to a toolbox
# and can use different tools to solve your problems!
# =================================================================

# STEP 1: SETUP - Installing and preparing our AI tools
# =================================================================
# This installs a special library that lets us talk to AI models
!pip install litellm

# These are like importing different tool sets into our workshop
import os                    # Tools for working with files and folders
from google.colab import userdata  # Tool to get our secret API key safely
api_key = userdata.get('OPENAI_API_KEY')  # Get our password to use OpenAI
os.environ['OPENAI_API_KEY'] = api_key    # Tell our computer about this password

from litellm import completion  # The main tool to talk to AI models
from typing import List, Dict   # Helper tools for organizing our code
import json                     # Tool for working with structured data
import re                       # Tool for finding patterns in text

# BRAIN FUNCTION - How our agent talks to the AI
# =================================================================
def generate_response(messages: List[Dict]) -> str:
    """
    This is like the BRAIN of our agent!

    Think of this as making a phone call to a very smart friend (GPT-4).
    We give them our conversation history, and they give us back advice.

    How it works:
    1. We send all our conversation messages to GPT-4
    2. GPT-4 thinks about what tool to use
    3. GPT-4 sends back instructions in a special format
    """
    # Make the "phone call" to GPT-4 with our conversation
    response = completion(
        model="openai/gpt-4o",      # Which AI brain to use (GPT-4o)
        messages=messages,          # Our conversation history
        max_tokens=1024            # Maximum length of response
    )
    # Extract just the text response from GPT-4's answer
    return response.choices[0].message.content

# SAGENT'S TOOLBOX - The tools our agent can use
# =================================================================
# Just like a real person has tools (hammer, screwdriver, etc.),
# our AI agent has digital tools it can use to help users

# Tool 1: List files in the current directory
def list_files() -> list:
    """
    This tool looks around the current folder and tells us what files are there.
    It's like asking "What's in this drawer?" and getting a list back.
    """
    return os.listdir(".")  # Get list of all files in current folder

# Tool 2: Read the contents of a file
def read_file(file_name: str) -> str:
    """
    This tool opens a file and reads what's inside it.
    It's like opening a book and reading the pages.
    """
    try:
        # Try to open and read the file
        with open(file_name, "r") as file:
            return file.read()
    except Exception as e:
        # If something goes wrong, tell us what happened
        return f"Error reading file: {e}"

# UNDERSTANDING AGENT RESPONSES - Parsing the AI's instructions
# =================================================================
# When GPT-4 responds, it gives us instructions in a special format.
# We need to extract and understand these instructions.

def extract_markdown_block(text: str, tag: str) -> str:
    """
    The AI responds with instructions wrapped in special markers (```action).
    This function finds and extracts just the instruction part.

    Example: If AI says "I'll help you ```action {"tool": "list_files"} ```"
    This function extracts just: {"tool": "list_files"}
    """
    start_tag = f"```{tag}"    # Look for ```action
    end_tag = "```"            # Look for closing ```

    if start_tag in text:
        # Split the text and get the middle part (the instruction)
        block = text.split(start_tag)[1].split(end_tag)[0]
        return block.strip()   # Remove extra spaces

    # If we can't find the instruction format, something went wrong
    raise ValueError("No valid action block found")

def parse_action(response: str) -> Dict:
    """
    This function takes the AI's response and turns it into clear instructions.

    Think of it like translating the AI's response into simple commands:
    "Use the list_files tool with no special settings"
    """
    try:
        # Step 1: Extract the instruction part from the AI's response
        response = extract_markdown_block(response, "action")

        # Step 2: Convert the instruction from text to a structured format
        response_json = json.loads(response)

        # Step 3: Check if the instruction has the required parts
        if "tool_name" in response_json and "args" in response_json:
            return response_json  # Return the clear instruction
        else:
            # If instruction is incomplete, return an error
            return {"tool_name": "error", "args": {"message": "You must respond with a JSON tool invocation."}}

    except json.JSONDecodeError:
        # If we can't understand the instruction, return an error
        return {"tool_name": "error", "args": {"message": "Invalid JSON response. You must respond with a JSON tool invocation."}}

# AGENT PERSONALITY AND RULES - Teaching the AI how to behave
# =================================================================
# This is like giving instructions to a new employee about their job

content = """You are an AI agent that can perform tasks by using available tools.

Available tools:
- list_files() -> List[str]: List all files in the current directory.
- read_file(file_name: str) -> str: Read the content of a file.
- terminate(message: str): End the agent loop and print a summary to the user.

If a user asks about files, list them before reading.
Every response MUST have an action.

Respond in this format:
```action
{
 "tool_name": "insert tool_name",
 "args": {...fill in any required arguments here...}
}
```"""

# Package these rules in a format the AI understands
agent_rules = [{
    "role": "system",     # This means "these are the rules"
    "content": content    # These are the actual rules
}]

# AGENT MEMORY - Keeping track of conversations
# =================================================================
# Just like humans remember conversations, our agent needs memory too!

memory = [
    # Example of what a conversation looks like in the agent's memory:
    {"role": "user", "content": "What files are in this directory?"},
    {"role": "assistant", "content": "```action\n{\"tool_name\":\"list_files\",\"args\":{}}\n```"},
    {"role": "user", "content": "[\"file1.txt\", \"file2.txt\"]"}
]

# THE MAIN AGENT LOOP - Where the magic happens!
# =================================================================
# This is the heart of our agent - the main conversation loop

# Set up loop controls (like a safety switch)
iterations = 0          # How many times we've gone through the loop
max_iterations = 5      # Maximum conversations to prevent infinite loops
memory = []             # Start with empty memory for new conversation

print("ðŸ¤– AI Agent is ready! Type 'terminate' when you want to stop.")

# THE MAIN LOOP: This runs over and over until we're done

# =================================================================
# SUMMARY: HOW THIS LOOP WORKS
# =================================================================
# 1. USER SPEAKS: Person types a message
# 2. AGENT THINKS: AI analyzes the message and conversation history
# 3. AGENT DECIDES: AI chooses which tool to use
# 4. AGENT ACTS: The chosen tool is executed
# 5. AGENT RESPONDS: Results are shared with the user
# 6. AGENT REMEMBERS: Conversation is stored for context
# 7. REPEAT: Process continues until user says stop
# =================================================================

while iterations < max_iterations:

    # Step 1: GET USER INPUT
    # =================================================================
    # Get new input from the user (like listening to what they say)
    user_input = input("\nðŸ’¬ You: ")

    # Add what the user said to our memory
    memory.append({"role": "user", "content": user_input})

    # Step 2: PREPARE THE CONVERSATION
    # =================================================================
    # Combine the agent's rules with the conversation history
    # This is like giving the AI both its job description AND the conversation so far
    prompt = agent_rules + memory

    # Step 3: GET AI'S DECISION
    # =================================================================
    # Ask the AI what tool to use (like asking a smart friend for advice)
    print("ðŸ§  Agent thinking...")
    response = generate_response(prompt)
    print(f"ðŸ¤– Agent response: {response}")

    # Step 4: UNDERSTAND THE AI'S DECISION
    # =================================================================
    # Turn the AI's response into clear instructions
    action = parse_action(response)
    result = "Action executed"  # Default result message

    # Step 5: EXECUTE THE CHOSEN TOOL
    # =================================================================
    # Based on what the AI decided, use the appropriate tool

    if action["tool_name"] == "list_files":
        # AI wants to list files - use our list_files tool
        result = {"result": list_files()}

    elif action["tool_name"] == "read_file":
        # AI wants to read a file - use our read_file tool
        # Get the filename from the AI's instructions
        result = {"result": read_file(action["args"]["file_name"])}

    elif action["tool_name"] == "error":
        # Something went wrong with understanding the AI's response
        result = {"error": action["args"]["message"]}

    elif action["tool_name"] == "terminate":
        # AI or user wants to end the conversation
        print(f"ðŸ”š {action['args']['message']}")
        break  # Exit the loop

    else:
        # AI asked for a tool we don't have
        result = {"error": "Unknown action: " + action["tool_name"]}

    # Show the user what happened
    print(f"âš™ï¸  Action result: {result}")

    # Step 6: UPDATE MEMORY
    # =================================================================
    # Remember this conversation turn for next time
    memory.extend([
        {"role": "assistant", "content": response},      # What the AI said
        {"role": "user", "content": json.dumps(result)}  # What the tool returned
    ])

    # Step 7: CHECK IF WE SHOULD STOP
    # =================================================================
    # Double-check if we should end the conversation
    if action["tool_name"] == "terminate":
        break

    # Increment our counter (safety mechanism)
    iterations += 1

# WRAP UP
# =================================================================
# Let the user know we're done
print(f"âœ… Agent loop completed after {iterations} iterations.")
print("ðŸ‘‹ Thanks for chatting with the AI Agent!")